# -*- coding: utf-8 -*-
"""models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cvJ342uGCQ2_7MILZeM1PX1FOC2b5B7F
"""

from __future__ import annotations

import random
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple


@dataclass(frozen=True)
class Item:
    id: str
    name: str
    type: str


@dataclass(frozen=True)
class Equipment(Item):
    slotType: str
    atkBonus: int
    defBonus: int


@dataclass
class ItemStack:
    item: Item
    qty: int

    def add(self, qty: int) -> None:
        self.qty += qty

    def subtract(self, qty: int) -> None:
        self.qty -= qty


class DropTable:
    """
    entries: (item, minQty, maxQty, probability[0..1])
    """
    def __init__(self, entries: List[Tuple[Item, int, int, float]]):
        self.entries: List[Tuple[Item, int, int, float]] = entries

    def roll(self) -> List[ItemStack]:
        drops: List[ItemStack] = []
        for item, min_q, max_q, prob in self.entries:
            if random.random() < prob:
                qty: int = random.randint(min_q, max_q)
                drops.append(ItemStack(item=item, qty=qty))
        return drops


class Inventory:
    def __init__(self) -> None:
        self.items: Dict[str, ItemStack] = {}

    def add(self, item: Item, qty: int) -> bool:
        if qty <= 0:
            return False
        if item.id in self.items:
            self.items[item.id].add(qty)
        else:
            self.items[item.id] = ItemStack(item=item, qty=qty)
        return True

    def remove(self, item_id: str, qty: int) -> bool:
        if qty <= 0 or item_id not in self.items:
            return False
        st: ItemStack = self.items[item_id]
        if st.qty < qty:
            return False
        st.subtract(qty)
        if st.qty == 0:
            del self.items[item_id]
        return True

    def get(self, item_id: str) -> Optional[ItemStack]:
        return self.items.get(item_id)

    def list_all(self) -> List[ItemStack]:
        return list(self.items.values())


class EquipmentSlot:
    def __init__(self, slotType: str) -> None:
        self.slotType: str = slotType
        self.equipped: Optional[Equipment] = None

    def equip(self, eq: Equipment) -> bool:
        if eq.slotType != self.slotType:
            return False
        self.equipped = eq
        return True

    def unequip(self) -> Optional[Equipment]:
        eq: Optional[Equipment] = self.equipped
        self.equipped = None
        return eq


class Character:
    def __init__(self, name: str, hp: int, atk: int, defense: int) -> None:
        self.name: str = name
        self.maxHp: int = hp
        self.hp: int = hp
        self.atk: int = atk
        self.defense: int = defense

    def is_alive(self) -> bool:
        return self.hp > 0

    def take_damage(self, amount: int) -> int:
        dmg: int = max(1, amount)
        self.hp = max(0, self.hp - dmg)
        return dmg

    def basic_attack(self, target: "Character", atk_value: Optional[int] = None) -> int:
        atk_val: int = self.atk if atk_value is None else atk_value
        raw: int = atk_val - target.defense
        return target.take_damage(raw)


class Player(Character):
    def __init__(self, name: str) -> None:
        super().__init__(name=name, hp=100, atk=12, defense=4)
        self.level: int = 1
        self.exp: int = 0
        self.expToNext: int = 30

        self.maxMp: int = 30
        self.mp: int = 30

        self.inventory: Inventory = Inventory()
        self.equipmentSlots: Dict[str, EquipmentSlot] = {
            "weapon": EquipmentSlot("weapon"),
            "armor": EquipmentSlot("armor"),
        }

    def get_total_atk(self) -> int:
        bonus: int = 0
        for slot in self.equipmentSlots.values():
            if slot.equipped:
                bonus += slot.equipped.atkBonus
        return self.atk + bonus

    def get_total_def(self) -> int:
        bonus: int = 0
        for slot in self.equipmentSlots.values():
            if slot.equipped:
                bonus += slot.equipped.defBonus
        return self.defense + bonus

    def gain_exp(self, amount: int) -> bool:
        self.exp += max(0, amount)
        leveled: bool = False
        while self.exp >= self.expToNext:
            self.exp -= self.expToNext
            self.level_up()
            leveled = True
        return leveled

    def level_up(self) -> None:
        self.level += 1
        self.maxHp += 10
        self.hp = self.maxHp
        self.atk += 2
        self.defense += 1
        self.maxMp += 5
        self.mp = self.maxMp
        self.expToNext = int(self.expToNext * 1.35) + 5

    def equip_from_inventory(self, item_id: str) -> bool:
        st: Optional[ItemStack] = self.inventory.get(item_id)
        if not st or not isinstance(st.item, Equipment):
            return False

        eq: Equipment = st.item
        slot: Optional[EquipmentSlot] = self.equipmentSlots.get(eq.slotType)
        if not slot:
            return False

        if slot.equipped and slot.equipped.id == eq.id:
            return False

        old: Optional[Equipment] = slot.unequip()
        if old:
            self.inventory.add(old, 1)

        if not self.inventory.remove(item_id, 1):
            if old:
                slot.equip(old)
                self.inventory.remove(old.id, 1)
            return False

        return slot.equip(eq)

    def unequip_to_inventory(self, slotType: str) -> bool:
        slot: Optional[EquipmentSlot] = self.equipmentSlots.get(slotType)
        if not slot or not slot.equipped:
            return False
        eq: Optional[Equipment] = slot.unequip()
        if eq:
            self.inventory.add(eq, 1)
        return True

    def use_potion(self, potion_id: str = "potion_small") -> bool:
        st: Optional[ItemStack] = self.inventory.get(potion_id)
        if not st or st.qty <= 0:
            return False
        if not self.inventory.remove(potion_id, 1):
            return False
        self.hp = min(self.maxHp, self.hp + 30)
        return True


class Enemy(Character):
    def __init__(self, name: str, hp: int, atk: int, defense: int, expReward: int, dropTable: DropTable) -> None:
        super().__init__(name=name, hp=hp, atk=atk, defense=defense)
        self.expReward: int = expReward
        self.dropTable: DropTable = dropTable

    def roll_drop(self) -> List[ItemStack]:
        return self.dropTable.roll()


class Map:
    def __init__(self, name: str, description: str, gatherTable: DropTable) -> None:
        self.name: str = name
        self.description: str = description
        self.gatherTable: DropTable = gatherTable

    def on_enter(self) -> List[ItemStack]:
        return self.gatherTable.roll()