# -*- coding: utf-8 -*-
"""game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KHyfeh9qPpmMMWDao_MD98QYF6t2-WRk
"""

from __future__ import annotations

import asyncio
from dataclasses import dataclass
from typing import AsyncIterator, List, Optional

from models import DropTable, Enemy, Equipment, Item, ItemStack, Map, Player
from utils import InputCancelled, Messages, iter_lines, prompt_choice, prompt_text


@dataclass(frozen=True)
class LogEvent:
    text: str


async def log_consumer(queue: asyncio.Queue[LogEvent]) -> None:

    while True:
        ev: LogEvent = await queue.get()
        if ev.text == "__STOP__":
            queue.task_done()
            break
        print(ev.text)
        queue.task_done()


async def stream_stacks(stacks: List[ItemStack]) -> AsyncIterator[ItemStack]:

    for st in stacks:
        yield st
        await asyncio.sleep(0)


class BattleController:

    def __init__(self, player: Player, enemy: Enemy, game_map: Map, logs: asyncio.Queue[LogEvent], msg: Messages) -> None:
        self.player = player
        self.enemy = enemy
        self.map = game_map
        self.logs = logs
        self.msg = msg

    async def on_enter_map(self) -> None:
        await self.logs.put(LogEvent(f"\n[맵 진입] {self.map.name} - {self.map.description}"))
        gathered: List[ItemStack] = self.map.on_enter()

        if not gathered:
            await self.logs.put(LogEvent(self.msg.GATHER_NONE))
            return

        await self.logs.put(LogEvent(self.msg.GATHER_SUCCESS))
        async for st in stream_stacks(gathered):
            self.player.inventory.add(st.item, st.qty)
            await self.logs.put(LogEvent(f" - {st.item.name} x{st.qty}"))

    async def run(self) -> None:
        await self.on_enter_map()
        await self.logs.put(LogEvent(f"\n[전투 시작] {self.enemy.name} 등장!"))

        while self.player.is_alive() and self.enemy.is_alive():
            escaped: bool = await self.player_turn()
            if escaped:
                await self.logs.put(LogEvent(self.msg.ESCAPE))
                return

            if not self.enemy.is_alive():
                await self.on_enemy_defeated()
                break

            await self.enemy_turn()

        if not self.player.is_alive():
            await self.logs.put(LogEvent("\n" + self.msg.DEFEAT))

    async def player_turn(self) -> bool:

        self.player.defense = self.player.get_total_def()

        await self.logs.put(LogEvent(
            f"\n[플레이어 턴] {self.player.name} HP {self.player.hp}/{self.player.maxHp}\n"
            f"[적 상태] {self.enemy.name} HP {self.enemy.hp}/{self.enemy.maxHp}\n"
            f"{self.msg.MENU_BATTLE}"
        ))

        choice: str = prompt_choice("선택: ", {"1", "2", "3"})
        if choice == "1":
            dmg: int = self.player.basic_attack(self.enemy, atk_value=self.player.get_total_atk())
            await self.logs.put(LogEvent(f"{self.enemy.name}에게 {dmg} 피해!"))
            return False
        if choice == "2":
            ok: bool = self.player.use_potion()
            await self.logs.put(LogEvent(self.msg.POTION_USED if ok else self.msg.NO_POTION))
            return False
        return True  # escape

    async def enemy_turn(self) -> None:
        await self.logs.put(LogEvent(f"\n[적 턴] {self.enemy.name}의 공격!"))
        dmg: int = self.enemy.basic_attack(self.player)
        await self.logs.put(LogEvent(f"{self.player.name}이(가) {dmg} 피해를 받았다!"))

    async def on_enemy_defeated(self) -> None:
        await self.logs.put(LogEvent(f"\n{self.enemy.name} 처치!"))
        drops: List[ItemStack] = self.enemy.roll_drop()

        if drops:
            await self.logs.put(LogEvent("[드롭 아이템]"))
            async for st in stream_stacks(drops):
                self.player.inventory.add(st.item, st.qty)
                await self.logs.put(LogEvent(f" - {st.item.name} x{st.qty}"))
        else:
            await self.logs.put(LogEvent("드롭 없음."))

        leveled: bool = self.player.gain_exp(self.enemy.expReward)
        await self.logs.put(LogEvent(f"[경험치] +{self.enemy.expReward} (현재 EXP: {self.player.exp}/{self.player.expToNext})"))
        if leveled:
            await self.logs.put(LogEvent(f"레벨 업! Lv.{self.player.level} (HP/MP 완전 회복)"))


def render_status_lines(player: Player) -> List[str]:
    w: Optional[Equipment] = player.equipmentSlots["weapon"].equipped
    a: Optional[Equipment] = player.equipmentSlots["armor"].equipped
    return [
        "\n[플레이어 상태]",
        f"이름: {player.name}",
        f"레벨: {player.level}",
        f"HP: {player.hp}/{player.maxHp}",
        f"MP: {player.mp}/{player.maxMp}",
        f"ATK: {player.get_total_atk()}  DEF: {player.get_total_def()}",
        f"무기: {w.name if w else '없음'}",
        f"갑옷: {a.name if a else '없음'}",
    ]


def render_inventory_lines(player: Player) -> List[str]:
    lines: List[str] = ["\n[인벤토리]"]
    stacks: List[ItemStack] = player.inventory.list_all()
    if not stacks:
        lines.append("비어 있음.")
        return lines
    for st in stacks:
        lines.append(f"- {st.item.name} ({st.item.id}) x{st.qty}")
    return lines


async def run_game() -> None:
    msg: Messages = Messages()
    logs: asyncio.Queue[LogEvent] = asyncio.Queue()
    consumer_task: asyncio.Task[None] = asyncio.create_task(log_consumer(logs))

    iron_ore: Item = Item(id="ore_iron", name="철광석", type="material")
    herb: Item = Item(id="herb_green", name="초록 약초", type="material")
    potion: Item = Item(id="potion_small", name="작은 포션", type="potion")
    sword: Equipment = Equipment(id="eq_sword", name="낡은 검", type="equipment", slotType="weapon", atkBonus=5, defBonus=0)
    armor: Equipment = Equipment(id="eq_armor", name="가죽 갑옷", type="equipment", slotType="armor", atkBonus=0, defBonus=3)

    gather_table: DropTable = DropTable([
        (iron_ore, 1, 3, 0.60),
        (herb, 1, 2, 0.55),
        (potion, 1, 1, 0.30),
    ])

    enemy_drop: DropTable = DropTable([
        (herb, 1, 2, 0.40),
        (potion, 1, 1, 0.25),
        (sword, 1, 1, 0.10),
        (armor, 1, 1, 0.08),
    ])

    game_map: Map = Map(name="초원", description="바람이 부는 평원이다.", gatherTable=gather_table)
    player: Player = Player(name="용사")
    player.inventory.add(potion, 2)

    try:
        while True:
            for line in iter_lines(["\n" + msg.APP_TITLE, msg.MENU_MAIN]):
                print(line)

            sel: str = prompt_choice("선택: ", {"1", "2", "3", "4", "5"})

            if sel == "1":
                enemy: Enemy = Enemy(name="고블린", hp=60, atk=10, defense=2, expReward=20, dropTable=enemy_drop)
                battle: BattleController = BattleController(player, enemy, game_map, logs, msg)
                await battle.run()

            elif sel == "2":
                for line in iter_lines(render_status_lines(player)):
                    print(line)

            elif sel == "3":
                for line in iter_lines(render_inventory_lines(player)):
                    print(line)

            elif sel == "4":
                await equip_menu(player, msg)

            else:
                print(msg.EXIT)
                break

    except InputCancelled:
        print("\n" + msg.INTERRUPTED)
    finally:
        await logs.put(LogEvent("__STOP__"))
        await logs.join()
        await consumer_task


async def equip_menu(player: Player, msg: Messages) -> None:
    for line in iter_lines(render_inventory_lines(player)):
        print(line)

    print("\n[장비 관리]")
    print(msg.MENU_EQUIP)

    c: str = prompt_choice("선택: ", {"1", "2", "3", "4"})

    if c == "1":
        print("장착할 장비 itemId 입력 (취소: q)")
        item_id: Optional[str] = prompt_text("> ", allow_cancel=True)
        if item_id is None:
            print(msg.CANCELLED)
            return
        ok: bool = player.equip_from_inventory(item_id)
        print("장착 완료!" if ok else "장착 실패(아이템 없음/장비 아님/슬롯 불일치/중복 장착).")

    elif c == "2":
        ok2: bool = player.unequip_to_inventory("weapon")
        print("weapon 해제: 성공" if ok2 else "weapon 해제: 실패(장착된 장비 없음).")

    elif c == "3":
        ok3: bool = player.unequip_to_inventory("armor")
        print("armor 해제: 성공" if ok3 else "armor 해제: 실패(장착된 장비 없음).")

    else:
        return