# -*- coding: utf-8 -*-
"""game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KHyfeh9qPpmMMWDao_MD98QYF6t2-WRk
"""

from __future__ import annotations

import asyncio
from dataclasses import dataclass
from typing import AsyncIterator, List, Optional

from models import DropTable, Enemy, Equipment, Item, ItemStack, Player
from utils import InputCancelled, Messages, iter_lines, prompt_choice, prompt_text


@dataclass(frozen=True)
class LogEvent:
    text: str


async def log_consumer(queue: asyncio.Queue[LogEvent]) -> None:
    while True:
        ev: LogEvent = await queue.get()
        if ev.text == "__STOP__":
            queue.task_done()
            break
        print(ev.text)
        queue.task_done()


async def stream_stacks(stacks: List[ItemStack]) -> AsyncIterator[ItemStack]:
    for st in stacks:
        yield st
        await asyncio.sleep(0)


def render_status_lines(player: Player) -> List[str]:
    w: Optional[Equipment] = player.equipmentSlots["weapon"].equipped
    a: Optional[Equipment] = player.equipmentSlots["armor"].equipped
    return [
        "\n[플레이어 상태]",
        f"이름: {player.name}",
        f"레벨: {player.level}",
        f"HP: {player.hp}/{player.maxHp}",
        f"MP: {player.mp}/{player.maxMp}",
        f"ATK: {player.get_total_atk()}  DEF: {player.get_total_def()}",
        f"무기: {w.name if w else '없음'}",
        f"갑옷: {a.name if a else '없음'}",
    ]


def render_inventory_lines(player: Player, msg: Messages) -> List[str]:
    lines: List[str] = ["\n[인벤토리]"]
    stacks: List[ItemStack] = player.inventory.list_all()
    if not stacks:
        lines.append(msg.INV_EMPTY)
        return lines
    for st in stacks:
        lines.append(f"- {st.item.name} ({st.item.id}) x{st.qty}")
    return lines


async def equip_menu(player: Player, msg: Messages) -> None:
    for line in iter_lines(render_inventory_lines(player, msg)):
        print(line)

    print("\n[장비 관리]")
    print(msg.MENU_EQUIP)

    c: str = prompt_choice("선택: ", {"1", "2", "3", "4"})

    if c == "1":
        print("장착할 장비 itemId 입력 (취소: q)")
        item_id: Optional[str] = prompt_text("> ", allow_cancel=True)
        if item_id is None:
            print(msg.CANCELLED)
            return
        ok: bool = player.equip_from_inventory(item_id)
        print("장착 완료!" if ok else "장착 실패(아이템 없음/장비 아님/슬롯 불일치/중복 장착).")

    elif c == "2":
        ok2: bool = player.unequip_to_inventory("weapon")
        print("weapon 해제: 성공" if ok2 else "weapon 해제: 실패(장착된 장비 없음).")

    elif c == "3":
        ok3: bool = player.unequip_to_inventory("armor")
        print("armor 해제: 성공" if ok3 else "armor 해제: 실패(장착된 장비 없음).")

    else:
        return


class BattleController:


    def __init__(self, player: Player, enemy: Enemy, logs: asyncio.Queue[LogEvent], msg: Messages) -> None:
        self.player = player
        self.enemy = enemy
        self.logs = logs
        self.msg = msg

    async def run(self) -> None:
        print(f"\n[전투 시작] {self.enemy.name} 등장!")

        while self.player.is_alive() and self.enemy.is_alive():
            escaped: bool = await self.player_turn()
            if escaped:
                print(self.msg.ESCAPE)
                return

            if not self.enemy.is_alive():
                await self.on_enemy_defeated()
                break

            await self.enemy_turn()

        if not self.player.is_alive():
            print("\n" + self.msg.DEFEAT)

    async def player_turn(self) -> bool:

        self.player.defense = self.player.get_total_def()

        print(
            f"\n[플레이어 턴] {self.player.name} HP {self.player.hp}/{self.player.maxHp}\n"
            f"[적 상태] {self.enemy.name} HP {self.enemy.hp}/{self.enemy.maxHp}\n"
            f"{self.msg.MENU_BATTLE}"
        )

        choice: str = prompt_choice("선택: ", {"1", "2", "3"})
        if choice == "1":
            dmg: int = self.player.basic_attack(self.enemy, atk_value=self.player.get_total_atk())
            print(f"{self.enemy.name}에게 {dmg} 피해!")
            return False

        if choice == "2":
            ok: bool = self.player.use_potion()
            print(self.msg.POTION_USED if ok else self.msg.NO_POTION)
            return False

        return True

    async def enemy_turn(self) -> None:
        print(f"\n[적 턴] {self.enemy.name}의 공격!")
        dmg: int = self.enemy.basic_attack(self.player)
        print(f"{self.player.name}이(가) {dmg} 피해를 받았다!")

    async def on_enemy_defeated(self) -> None:
        print(f"\n{self.enemy.name} 처치!")

        drops: List[ItemStack] = self.enemy.roll_drop()
        if drops:
            print("[드롭 아이템]")
            async for st in stream_stacks(drops):
                self.player.inventory.add(st.item, st.qty)
                print(f" - {st.item.name} x{st.qty}")
                await self.logs.put(LogEvent(f"[LOG] DROP: {st.item.id} x{st.qty}"))
        else:
            print("드롭 없음.")
            await self.logs.put(LogEvent("[LOG] DROP: none"))

        leveled: bool = self.player.gain_exp(self.enemy.expReward)
        print(f"[경험치] +{self.enemy.expReward} (현재 EXP: {self.player.exp}/{self.player.expToNext})")
        await self.logs.put(LogEvent(f"[LOG] EXP: +{self.enemy.expReward}"))

        if leveled:
            print(f"레벨 업! Lv.{self.player.level} (HP/MP 완전 회복)")
            await self.logs.put(LogEvent(f"[LOG] LEVEL_UP: {self.player.level}"))


async def run_game() -> None:
    msg: Messages = Messages()
    logs: asyncio.Queue[LogEvent] = asyncio.Queue()
    consumer_task: asyncio.Task[None] = asyncio.create_task(log_consumer(logs))

    herb: Item = Item(id="herb_green", name="초록 약초", type="material")
    potion: Item = Item(id="potion_small", name="작은 포션", type="potion")
    sword: Equipment = Equipment(id="eq_sword", name="낡은 검", type="equipment", slotType="weapon", atkBonus=5, defBonus=0)
    armor: Equipment = Equipment(id="eq_armor", name="가죽 갑옷", type="equipment", slotType="armor", atkBonus=0, defBonus=3)

    enemy_drop: DropTable = DropTable([
        (herb, 1, 2, 0.40),
        (potion, 1, 1, 0.25),
        (sword, 1, 1, 0.10),
        (armor, 1, 1, 0.08),
    ])

    player: Player = Player(name="용사")
    player.inventory.add(potion, 2)

    try:
        while True:
            for line in iter_lines(["\n" + msg.APP_TITLE, msg.MENU_MAIN.replace("맵 진입(채집+전투)", "전투 시작")]):
                print(line)

            sel: str = prompt_choice("선택: ", {"1", "2", "3", "4", "5"})

            if sel == "1":
                enemy: Enemy = Enemy(name="고블린", hp=60, atk=10, defense=2, expReward=20, dropTable=enemy_drop)
                battle: BattleController = BattleController(player, enemy, logs, msg)
                await battle.run()

            elif sel == "2":
                for line in iter_lines(render_status_lines(player)):
                    print(line)

            elif sel == "3":
                for line in iter_lines(render_inventory_lines(player, msg)):
                    print(line)

            elif sel == "4":
                await equip_menu(player, msg)

            else:
                print(msg.EXIT)
                break

    except InputCancelled:
        print("\n" + msg.INTERRUPTED)
    finally:
        await logs.put(LogEvent("__STOP__"))
        await logs.join()
        await consumer_task